#include <iostream>
#include "PcapLiveDeviceList.h"
#include "SystemUtils.h"


/**
 * A struct for collecting packet statistics
 */
struct PacketStats
{
    int ethPacketCount;
    int ipv4PacketCount;
    int ipv6PacketCount;
    int tcpPacketCount;
    int udpPacketCount;
    int dnsPacketCount;
    int httpPacketCount;
    int sslPacketCount;


    /**
     * Clear all stats
     */
    void clear() { ethPacketCount = 0; ipv4PacketCount = 0; ipv6PacketCount = 0; tcpPacketCount = 0; udpPacketCount = 0; tcpPacketCount = 0; dnsPacketCount = 0; httpPacketCount = 0; sslPacketCount = 0; }

    /**
     * C'tor
     */
    PacketStats() { clear(); }

    /**
     * Collect stats from a packet
     */
    void consumePacket(pcpp::Packet& packet)
    {
        if (packet.isPacketOfType(pcpp::Ethernet))
            ethPacketCount++;
        if (packet.isPacketOfType(pcpp::IPv4))
            ipv4PacketCount++;
        if (packet.isPacketOfType(pcpp::IPv6))
            ipv6PacketCount++;
        if (packet.isPacketOfType(pcpp::TCP))
            tcpPacketCount++;
        if (packet.isPacketOfType(pcpp::UDP))
            udpPacketCount++;
        if (packet.isPacketOfType(pcpp::DNS))
            dnsPacketCount++;
        if (packet.isPacketOfType(pcpp::HTTP))
            httpPacketCount++;
        if (packet.isPacketOfType(pcpp::SSL))
            sslPacketCount++;
    }

    void isSuspicious(){
        if(httpPacketCount>100){
            //clearing the stats and start counting again for warning suspicious activity.
            clear();
            std::cout<<"Warning: There is more than "<<httpPacketCount<<"Http packets in capture while you were not browsing!!" ;
        }
    }

};


/**
 * A callback function for the async capture which is called each time a packet is captured
 */
static void onPacketArrives(pcpp::RawPacket* packet, pcpp::PcapLiveDevice* dev, void* cookie)
{
    // extract the stats object form the cookie
    PacketStats* stats = (PacketStats*)cookie;
    // parsed the raw packet
    pcpp::Packet parsedPacket(packet);
    // collect stats from packet
    stats->consumePacket(parsedPacket);
    //Warning if needed:
    stats->isSuspicious();
}

/**
 * main method of the application
 */
int main()
{
    //Capturing loopback traffic device (127.0.0.1)
    pcpp::PcapLiveDevice* dev=pcpp::PcapLiveDeviceList::getInstance().getPcapLiveDeviceByName("lo");

    if (dev == nullptr)
    {
        std::cerr << "Cannot find interface" << std::endl;
        return 1;
    }

    // Get device info
    // ~~~~~~~~~~~~~~~
    // before capturing packets we will print some info about this interface
    std::cout
            << "Interface info:" << std::endl
            << "   Interface name:        " << dev->getName() << std::endl // get interface name
            << "   Interface description: " << dev->getDesc() << std::endl // get interface description
            << "   MAC address:           " << dev->getMacAddress() << std::endl // get interface MAC address
            << "   Default gateway:       " << dev->getDefaultGateway() << std::endl // get default gateway
            << "   Interface MTU:         " << dev->getMtu() << std::endl; // get interface MTU

    // open the device before start capturing/sending packets
    if (!dev->open())
    {
        //Close the program if we couldn't open the device
        std::cerr << "Cannot open device" << std::endl;
        return 1;
    }

    // create the stats object
    PacketStats stats;


    // Async packet capture with a callback function
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    while(true){

        //Starting the async capture to update the stats
        std::cout << std::endl << "Starting async capture..." << std::endl;

        // start capture in async mode. Give a callback function to call to whenever a packet is captured and the stats object as the cookie
        dev->startCapture(onPacketArrives, &stats);

        // sleep for 100 seconds in main thread, in the meantime packets are captured in the async thread
        pcpp::multiPlatformSleep(100);

        //Stoping the capture at the end of the while
        dev->stopCapture();
    }

}